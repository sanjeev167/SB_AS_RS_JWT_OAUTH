/**
 * 
 */
package com.pon.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.core.io.ClassPathResource;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.DefaultTokenServices;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;
import org.springframework.security.oauth2.provider.token.store.KeyStoreKeyFactory;

/**
 * @author Sanjeev Kumar
 * @Date   Dec 11, 2018
 * @Time   12:08:38 AM
 */

/**
 * If we annotate a configuration class with @EnableAuthorizationServer, and
 * provide the properties security.oauth2.client.client-id and
 * security.oauth2.client.client-secret, Spring will give us an authentication
 * server, providing standard Oauth2 tokens at the end point /oauth/token.
 **/


@Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {

	private int accessTokenValiditySeconds = 10000;
	private int refreshTokenValiditySeconds = 30000;

	@Value("${security.oauth2.resource.id}")
	private String resourceId;

	/**
	 * It has been injected here to encode client password while authenticating the
	 * client credential. This bean has been created somewhere else. now it has been
	 * created in security config file.
	 **/
	@Autowired
	BCryptPasswordEncoder passwordEncoder;

	@Autowired
	private AuthenticationManager authenticationManager;// Has already been exposed in WebSecurityConfig

	/**
	 * However, since we had turned off the default configuration, we must provide
	 * an AuthorizationServerConfigurerAdapter bean to correctly setup the
	 * authorization server. Like on theWebSecurityConfigurerAdapter ,
	 * theAuthorizationServerConfigurerAdapter relies on some methods that can be
	 * overridden to setup the configuration. The main methods are:
	 **/

	/**
	 * [1] Configure the security of the Authorization Server, which means in
	 * practical terms the /oauth/token endpoint.
	 **/

	@Override
	public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {
		oauthServer
				// we're allowing access to the token only for clients with
				// 'ROLE_TRUSTED_CLIENT' authority

				.tokenKeyAccess("hasAuthority('ROLE_TRUSTED_CLIENT')")
				.checkTokenAccess("hasAuthority('ROLE_TRUSTED_CLIENT')");
	}

	/**
	 * Configure the ClientDetailsService, declaring individual clients and their
	 * properties
	 **/

	@Override
	public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
		clients.inMemory().withClient("trusted-app")
				.authorizedGrantTypes("client_credentials", "password", "refresh_token")
				.authorities("ROLE_TRUSTED_CLIENT").scopes("read", "write").resourceIds(resourceId)
				.accessTokenValiditySeconds(accessTokenValiditySeconds)
				.refreshTokenValiditySeconds(refreshTokenValiditySeconds).secret(passwordEncoder.encode("secret"));
	}

	/**
	 * Configure the non-security features of the Authorization Server endpoints,
	 * like token store, token customizations, user approvals and grant types.
	 * 
	 * Remark: Even if we don't configure it, the default token store will work and
	 * a token reference type token will be generated by Spring framework.
	 * 
	 * 
	 * To provide the JWT, weâ€™ll need to create a JwtTokenStore, a
	 * JwtAccessTokenConverter and a DefaultTokenServices bean, and wire all that to
	 * the AuthorizationServerEndpointsConfigurer. So, add the following lines in
	 * our AuthorizationConfig class:
	 **/

	/*
	 * @Bean public JwtAccessTokenConverter accessTokenConverter() {
	 * JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
	 * converter.setSigningKey("abcd");//A dummy key used for testing purpose return
	 * converter; }
	 */

	@Value("${local.keystore.password}")
	private String kestorePwd;

	/**
	 * This is used for cor converting jwt token as per certificate which will be
	 * used by tokenstore latter.
	 **/

	@Bean
	public JwtAccessTokenConverter accessTokenConverter() {
		JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
		KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(new ClassPathResource("mykeys.jks"),
				kestorePwd.toCharArray());
		converter.setKeyPair(keyStoreKeyFactory.getKeyPair("mykeys"));
		return converter;
	}

	/**
	 * JwtTokenStore: Using access token converter , a token store will store token
	 **/
	@Bean
	public TokenStore tokenStore() {
		return new JwtTokenStore(accessTokenConverter());
	}

	@Bean
	@Primary
	public DefaultTokenServices tokenServices() {
		DefaultTokenServices defaultTokenServices = new DefaultTokenServices();
		defaultTokenServices.setTokenStore(tokenStore());
		defaultTokenServices.setSupportRefreshToken(true);
		defaultTokenServices.setTokenEnhancer(accessTokenConverter());
		return defaultTokenServices;
	}

	/**
	 * Finally configure AuthorizationServerEndpointsConfigurer. Configure the
	 * non-security features of the Authorization Server endpoints, like token
	 * store, token customizations, user approvals and grant types.
	 **/
	@Override
	public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
		endpoints.authenticationManager(this.authenticationManager).tokenServices(tokenServices())
				.tokenStore(tokenStore()).accessTokenConverter(accessTokenConverter());
	}

}
